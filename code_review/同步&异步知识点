
[synchronized]

可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，
同时它还可以保证共享变量的内存可见性

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

1.普通同步方法，锁是当前实例对象

2.静态同步方法，锁是当前类的class对象

3.同步方法块，锁是括号里面的对象


/-----------------------------------------------------------------------------------/
同步代码块：线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；

同步方法：在Class字节码文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，
表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。


/-----------------------------------------------------------------------------------/
Java对象头和monitor是实现synchronized的基础

[Java对象头]

1.synchronized用的锁是存在Java对象头里

2.对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针)

3.Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

4.Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。它是实现轻量级锁和偏向锁的关键

Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）
下图是Java对象头的存储结构（32位虚拟机）：

----------------------------------------------------------------------------------------------------
            25bit       |            4bit       |          1bit         |            2bit       |
----------------------------------------------------------------------------------------------------
       对象的hashCode   |       对象的分代年龄  |       是否是偏向锁    |           锁标志位    |
----------------------------------------------------------------------------------------------------

对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化



[Monitor]

Monitor可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。

对象头的MarkWord中的LockWord指向monitor的起始地址，，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用


/-----------------------------------------------------------------------------------/
[锁优化]