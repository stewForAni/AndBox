
[synchronized]

可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，
同时它还可以保证共享变量的内存可见性

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

1.普通同步方法，锁是当前实例对象

2.静态同步方法，锁是当前类的class对象

3.同步方法块，锁是括号里面的对象







/-----------------------------------------------------------------------------------/
同步代码块：线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；

同步方法：在Class字节码文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，
表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。








/-----------------------------------------------------------------------------------/
Java对象头和monitor是实现synchronized的基础

[Java对象头]

1.synchronized用的锁是存在Java对象头里

2.对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针)

3.Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

4.Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。它是实现轻量级锁和偏向锁的关键

Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）
下图是Java对象头的存储结构（32位虚拟机）：

----------------------------------------------------------------------------------------------------
            25bit       |            4bit       |          1bit         |            2bit       |
----------------------------------------------------------------------------------------------------
       对象的hashCode   |       对象的分代年龄  |       是否是偏向锁    |           锁标志位    |
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------
            锁状态       |     是否是偏向锁（1bit）    |  锁标志位（2bit）       
----------------------------------------------------------------------------
           无锁状态      |             0                |          01  
           轻量级锁      |             0                |          00  
           重量级锁      |             0                |          10  
           GC标志        |             0                |          11  
           偏向锁        |             1                |          01  
----------------------------------------------------------------------------
（http://cmsblogs.com/?p=2071）
 

对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化


[Monitor]

Monitor可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。
每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址）
同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用










/-----------------------------------------------------------------------------------/
[锁优化]

1.自旋锁
让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁，即执行一段无意义的循环，循环默认次数10（自旋）。

2.适应自旋锁
线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

3.锁消除
如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。
如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作
-----------------------------------------------------------------------------------

    public void vectorTest(){

        Vector<String> vector = new Vector<String>();

        for(int i = 0 ; i < 10 ; i++){
            vector.add(i + "");
        }

        System.out.println(vector);

    }

-----------------------------------------------------------------------------------
在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。

4.锁粗化
将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。
如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。

5.轻量级锁

1）获取锁

【1】.判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；

【2】.JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，
如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；

【3】.判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；


2）释放锁

轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：

【1】.取出在获取轻量级锁保存在Displaced Mark Word中的数据；

【2】.用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；

【3】.如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。

查看【轻量级锁的获取和释放过程】图片


6.偏向锁

引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可

1）获取锁

【1】.检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；

【2】.若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；

【3】.如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；

【4】.通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，
然后被阻塞在安全点的线程继续往下执行同步代码块；

【5】.执行同步代码块

2）释放锁

查看【偏向锁的获取和释放流程】图片


7.重量级锁

重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。














/-----------------------------------------------------------------------------------/
/-----------------------------------------------------------------------------------/
/-----------------------------------------------------------------------------------/

[volatile]

volatile是轻量级的synchronized

一个变量如果用volatile修饰了，则Java可以确保所有线程看到这个变量的值是一致的，如果某个线程对volatile修饰的共享变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。


/-----------------------------------------------------------------------------------/

[java内存模型相关概念]

计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。

有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。举一个简单的例子：

---------------------
 i++
---------------------

当线程运行这段代码时，首先会从主存中读取i( i = 1)，然后复制一份到CPU高速缓存中，然后CPU执行 + 1 （2）的操作，然后将数据（2）写入到告诉缓存中，最后刷新到主存中。其实这样做在单线程中是没有问题的，有问题的是在多线程中。如下：

假如有两个线程A、B都执行这个操作（i++），按照我们正常的逻辑思维主存中的i值应该=3，但事实是这样么？分析如下：

两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。

解决缓存一致性方案有两种：

1).通过在总线加LOCK#锁的方式

2).通过缓存一致性协议

但是方案1存在一个问题，它是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。

第二种方案，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。




/-----------------------------------------------------------------------------------/

[java内存模型]

///////原子性///////：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

-------------------------------------------------------------
  i = 0;             ------1

  j = i ;            ------2
  
  i++;               ------3
  
  i = j + 1;         ------4
-------------------------------------------------------------

1—在Java中，对基本数据类型的变量和赋值操作都是原子性操作；
2—包含了两个操作：读取i，将i值赋值给j
3—包含了三个操作：读取i值、i + 1 、将+1结果赋值给i；
4—同三一样

在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。

[volatile是无法保证复合操作的原子性]



///////可见性///////：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
Java提供了volatile来保证可见性。
当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。当然，synchronize和锁都可以保证可见性。


///////有序性///////：即程序执行的顺序按照代码的先后顺序执行。
