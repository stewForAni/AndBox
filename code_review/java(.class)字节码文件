/-----------------------------------------------------------------------------------/
/-----------------------------------我是分割线--------------------------------------/
/-----------------------------------------------------------------------------------/

[什么是字节码]


   .java文件  ----->   java compiler（用javac编译源代码）-----> .class文件

   -----> class loader -----> bytecode verifier -----> java runtime system -------> native os

          -----------------------------------------jvm---------------------------------------

查看【（字节码）java文件从编译到运行】图片




 对于开发人员，了解字节码可以更准确、直观地理解Java语言中更深层次的东西，比如通过字节码，可以很直观地看到Volatile关键字如何在字节码上生效。
 另外，字节码增强技术在Spring AOP、各种ORM框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于JVM规范的存在，
 只要最终可以生成符合规范的字节码就可以在JVM上运行，因此这就给了各种运行在JVM上的语言（如Scala、Groovy、Kotlin）一种契机，
 可以扩展Java所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。







 /-----------------------------------------------------------------------------------/

[字节码结构]

.java文件通过javac编译后将得到一个.class文件，比如编写一个简单的ByteCodeDemo类

查看【（字节码）ByteCodeDemo】图片

编译后生成ByteCodeDemo.class文件，打开后是一堆十六进制数，按字节为单位进行分割。

查看【（字节码）ByteCodeDemo】图片

JVM对于字节码是有规范要求的，JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成


|-------||-------||----------||-------------||----------||-----------||-----------||--------||---------||----------|
   魔数    版本号    常量池      访问标志     当前类索引    父类索引     接口索引    字段表    方法表     附加属性


查看【（字节码）JVM规定的字节码结构】图片


1） 魔数（Magic Number）

所有的.class文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE。魔数放在文件开头，
JVM可以根据文件的开头来判断这个文件是否可能是一个.class文件，如果是，才会继续进行之后的操作。
(有趣的是，魔数的固定值是Java之父James Gosling制定的，为CafeBabe（咖啡宝贝），而Java的图标为一杯咖啡。)

2）版本号

版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。
上图2中版本号为“00 00 00 34”，次版本号转化为十进制为0，主版本号转化为十进制为52，
在Oracle官网中查询序号52对应的主版本号为1.8，所以编译该文件的Java版本号为1.8.0。

3）常量池（Constant Pool）

紧接着主版本号之后的字节为常量池入口。常量池中存储两类常量：字面量与符号引用。
字面量为代码中声明为Final的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。
常量池整体上分为两部分：常量池计数器以及常量池数据区。




     2字节）
|----------------||-------------------------------------------------|
   常量池计数器                    常量池数据区




【1】常量池计数器（constant_pool_count）：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。
图2中示例代码的字节码前10个字节如下图所示，将十六进制的24转化为十进制值为36，排除掉下标“0”，也就是说，这个类文件中共有35个常量。

///////////（常量池计数器是从1开始的，在constant_pool表中，只有索引大于0且小于constant_pool_count的项才是有效的。）///////////

CA FE BA BE  |  00 00 00 34  |  00 24
--------------------------------------
     魔数         版本号        常量池
                                计数器




【2】常量池数据区：数据区是由（constant_pool_count - 1）个cp_info结构组成，一个cp_info结构对应一个常量。
在字节码中共有14种类型的cp_info（查看【（字节码）各类型的cp_info】图片），每种类型的结构都是固定的。


具体以CONSTANT_utf8_info为例
查看【（字节码）CONSTANT_utf8_info的结构（左）及示例（右）】图片

第一个字节"tag"，值为“01”，长度：1字节。
第二个字节"length"，值为该utf8字符串的长度，长度：2字节。
第三个字节"bytes"，值为length个字节的具体数据，长度：length个字节。


从   查看【（字节码）ByteCodeDemo】图片   中摘取一个cp_info结构
查看【（字节码）CONSTANT_utf8_info的结构（左）及示例（右）】图片 （01 00 01 61）
01是tag，00 01 表示字符串的长度，61转换成十进制是97，对照ascii表示a



4）访问标志

常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。
JVM规范规定了（查看【（字节码）访问标志】图片）的访问标志（Access_Flag）。需要注意的是，
JVM并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为Public Final，
则对应的访问修饰符的值为ACC_PUBLIC | ACC_FINAL，即0x0001 | 0x0010=0x0011。



5）当前类名

访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。



6）父类名称

当前类名的后两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。



7）接口信息

父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。



8）字段表

字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。
字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info。字段表结构如下图所示：

查看【（字节码）字段表结构】图片

从图中摘取字段为例：

0001 0002 0007 0008 0000
____ ____ ____ ____ ____

0001表示：字段计数器，共一个字段
0002表示：（查看【（字节码）访问标志】图片） 访问标志private
0007表示：字段名的索引，从常量池反编译结果中查看索引对应的值，a
0008表示：字段描述符索引，从常量池反编译结果中查看索引对应的值，I （int）
 
综上可以确定出类中声明的一个变量  private int a



9）方法表

字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数；第二部分为每个方法的详细信息。
方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，如下图所示：
 
查看【（字节码）方法表结构】图片


方法的权限修饰符依然可以通过（查看【（字节码）访问标志】图片）的值查询得到

方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到 （查看【（字节码）常量池反编译结果 】图片）。

而“方法的属性”这一部分较为复杂，直接借助javap -verbose将其反编译为人可以读懂的信息进行解读，（查看【（字节码）反编译后的方法表】图片）。
可以看到属性中包括以下三个部分：

1]code区：源代码对应的JVM指令操作码，在进行字节码增强时重点操作的就是“Code区”这一部分。

2]LineNumberTable：行号表，将Code区的操作码和源代码中的行号对应，Debug时会起到作用（源代码走一行，需要走多少个JVM指令操作码）。

3]LocalVariableTable：本地变量表，包含This和局部变量，之所以可以在每一个方法内部都可以调用This，是因为JVM将This作为每一个方法的
第一个参数隐式进行传入。当然，这是针对非Static方法而言。



10) 附加属性表

字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。








 /-----------------------------------------------------------------------------------/

[字节码操作集合]